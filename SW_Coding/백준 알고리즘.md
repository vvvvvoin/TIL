# 백준 알고리즘

## 문자열

### 팰린드롬?

- [링크](https://www.acmicpc.net/problem/10942)

- 팰린드롬이란 앞, 뒤에서 부터 글자를 읽어 두 포인터가 만날때까지 서로 글자가 같은 것을 팰린드롬이라고 한다.
- 팰린드롬을 찾기 위해서는 두개의 포인터를 선언한 for문을 통해 확인할 수 있다.
- 하지만 찾고자 하는 경우의 수가 많을 경우 매번 두 포인터로 비교하는 과정에서 성능이 저하된다.
- 그래서 DP을 이용하여 사전에 미리 두 포인터 구간이 팰린드롬인지 찾으면 된다.
- 팰림드롬이 되기 위한 조건은 두 가지가 존다한다.
  - 앞, 뒤 문자열이 같아야 한다.
  - 앞, 뒤 문자열을 제외한 나머지 문자열이 팰린드롬이어야 한다.
- 이 두가지 조건을 통해 작은 것부터 팰린드롬인지 확인하여 큰것을 찾아나가면 된다.

```java
// 작은 것부터 시작 위치가 i 부터 i까지인 구간을 true로 팰린드롬인 것으로 만든다. (길이가 1)
for(int i = 1; i <= size; i++) {
	dp[i][i] = true;
}

// 길이가2인 구간은 앞,뒤가 같으면 팰린드롬이다.
// 길이가2이므로 size직전까지
for(int i = 1; i < size; i++) {
	if(arr[i] == arr[i + 1]) {
		dp[i][i+1] = true;
	}
}

// i는 j부터 +i한 문자열을 의미한다.
// j는 문자열이 어디서 부터 시작하는 의미이다.
// 이때 i의 길이에 맞게 nullPointer예외가 나지 않도록 문자열길이size에서 i를 빼준다.
// arr[j] == arr[j + i]는 j부터 시작하는 문자열에서 j+i하여 문자열의 끝과 같은지 비교
// dp[j+1][i + j -1] 앞뒤를 제외한 이전에 구한 문자열이 팰린드롬인지 확인
for(int i = 2; i < size; i++) {
	for(int j = 1; j <= size - i ; j++) {
        // 조건1				// 조건 2
		if(arr[j] == arr[j + i] && dp[j+1][i + j -1] == true) {
		dp[j][j + i] = true;
		}
	}
}
```

- 두개의 포인터를 사용했을때보다 DP가 약2배 빠른 성능을 보여준다.

### LCS 최장 공통 부분 수열

- [문제1](https://www.acmicpc.net/problem/9251), [문제2](https://www.acmicpc.net/problem/9252), [문제3](https://www.acmicpc.net/problem/1958)

- 두 수열이 있을때 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.
- 즉 연속되지 않고 순서에 맞게 나열 했을때 두 수열과 비교해서 가장 큰 수열을 찾는 것이다.
- 두 가지 경우가 존재한다.
  - 두 수열에서 문자를 하나씩 비교했을 때 같은 경우 이전에 구했던 값과 누적한다.
  - 만약 다를 경우 이전에 존재했던 경우에서 가장 큰 값을 갖는다
- 즉  ACAYKP와 CAPCAK 두가지 수열이 있을 경우 첫번째 수열의 첫번재 문자 A와 두번째 수열과 비교하여 0, 1, 1, 1, 1, 1의 결과얻는다.
- 이 때 두번째 수열에 A가 두개인데 1인 이유는
  - 두번째 수열의 두번째 문자열A에서 시작하는 LCS의 경우
  - 두번째 수열의 다섯번째 문자열A에서 시작한 LCS의 경우
- 즉 별개의 것이기 때문이다.

```java
int[][] dp = new int[str1.length + 1][str2.length + 1];
		
for(int i = 1; i < str1.length + 1; i++) {
	for(int j = 1; j < str2.length + 1; j++) {
        //문자열 인덱스는 0부터 시작하므로 -1해준다
        //해당 인덱스의 문자가 서로 같다면 이전에 구한 경우에서 현재 자신의 경우를 +1 해준다.
		if(str1[i - 1].equals(str2[j - 1])) {
			dp[i][j] = dp[i - 1][j - 1] + 1;
        //해당 인덱스의 문자가 서로 다르면 현재 인덱스까지 왔을 때에 중 가장 큰 값을 매핑한다.
		}else {
			dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
		}
	}
}
```

- 그리고 dp의 가장 마지막 열, 행에 있는 값이 LCS의 길이가 된다.
- LCS 문자열을 구하기 위해서는 다음과 같이 구할수 있다.

```java
Stack<String> stack = new Stack<String>();
int i = str1.length;
int j = str2.length;
while(i >= 1 && j >= 1) {
	if(dp[i][j] == dp[i - 1][j]) {
		i--;
	}else if(dp[i][j] == dp[i][j - 1]) {
		j--;
	}else {
		stack.add(str1[i - 1]);
		i--;
		j--;
	}
}
while(!stack.isEmpty()) {
	System.out.print(stack.pop());
}
```

> 문자가 3개일 경우 3차원 배열로 해결할 수 있다.

## 수학

### 유클리드 호제법

- 유클리트 호제법은 2개의 자연수의 최대공약수를 구하는 알고리즘이다

```java
private static int findGcd(int a, int b) {
	int temp = 0;
	while(b > 0) {
		temp = a;
		a = b;
		b = temp%b;
	}
	return a;
}
```

 
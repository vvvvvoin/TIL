# 올림피아 문제

### DP, Double형 반올림

- [문제](https://www.acmicpc.net/problem/2670)

- 연속으로 존재하는 숫자들 중 한 개이상의 연속된 수들의 곱이 최대가 부분을 찾아 해당 값중 가장 큰 값을 리턴하는 문제이다.

- 모든 경우의 수를 찾을 수 있겠지만 시간초과가 걸린다

- 이 문제는 DP를 이용해야하는데 최근 저장해야할 값을 지정해야한다.

- 초기값에 인덱스0을 입력하고 인덱스1 부터 시작한다.

  - 현재값(인덱스 0)과 다음값(인덱스 1)의 곱이 다음값(인덱스 1)보다 작을 경우 값이 커지는 경우가 없기에 초기값을 다음 값으로 변경한다.
  - 현재값(인덱스 0)과 다음값((인덱스 1)의 곱이 다음값(인덱스 1보다 큰 경우 값을 누적한다
  - 그리고 누적되거나 변경된 값을 Max값과 비교한다

- 결과로 최대값을 리턴하는데 소수점4 째자리에서 반올림하여 3째자리까지 표현해야한다

- 반올림을 하는데 문제마다 정답이 콘솔, 리턴값이 다르기에 다음과 같이 표현한다.

  ```java
  max = (double)Math.round(max*1000)/1000;
  System.out.printf("%.3f", max);
  ////////////////////////////////////////
  max = (double)Math.round(max*1000)/1000;
  answer = String.format("%.3f", max);
  ```

  > SW test사이트 마다 다른데 Math.round()만 사용해도 되는 경우가 있는 반면 포맷을 정해줘야 정답인 경우가 있다.

### 플로이드 와샬 알고리즘

- [문제](https://www.acmicpc.net/problem/2660)

- 어느 회원이 다른 모든 회원과 친구이면(거리가 1이면) 이 회원의 점수는1점, 어느회원이 다른 모든 회원이 친구이거나 친구의 친구인 경우는 2점, 이러한 방식으로 각 회원에거 점수를 부여한다.

- 즉 회원으로부터 멀리 떨어진 회원의 최소 거리를 찾는 문제이다.

- 플로이드 와샬 알고리즘을 통해 최소거리를 구한다

- 플로이드 와샬

  1. N명의 인원 수 만큼 크기 N*N인 배열을 만든다

  2. 배열을 초기화하는데 인덱스가 같은 곳을 제외하고 INF값을 준다.

  3. ```java
     //플로이드 와샬 알고리즘
     //기준이 되는 거쳐가는 노드 K
     for(int k = 1; k <= n; k++) {
         //출발하는 노드 i
     	for(int i = 1; i <= n; i++) {
     		//도착하는 노트
     		for(int j = 1; j <= n; j++) {
                 //i에서 k를 거쳤다가 k에서 j 까지 가는 거리와 i에서 j 까지 가는 거리를 비교해서 작은 값이 최소거리이다.
     			array[i][j] = Math.min(array[i][k] + array[k][j], array[i][j]);
     		}
     	}
     }
     ```

- 그 후 각 회원마다 가지는 점수 중 가장 작은 값을 찾아 회장후보의 점수와 후보 수를 구하도록 한다.

  ```java
  int[] score = new int[n + 1];
  int max = 0;
  int min = INF;
  for(int i = 1; i <= n; i++) {
  	max = 0;
  	for(int j = 1; j <= n; j++) {
  		if(array[i][j] == INF) continue;
  		max = Math.max(array[i][j], max);
  	}
  	score[i] = max;	//score 배열을 돌아 min값인 회원 후보를 찾으며, 후보의 수를 찾는다.
  	min = Math.min(score[i], min);
  }
  ```

  
### 사고개념

- [멀쩡한 사각형](https://github.com/vvvvvoin/SWcoding/blob/master/src/programers_Lv2/Exam04.java)
- [문제](https://programmers.co.kr/learn/courses/30/lessons/62048)
  - 직사각형에 꼭지점에서 꼭지점으로 사선을 그렸을대 사선에 포함되는 작은 사각형을 제외한 작은 사각형의 갯수를 찾는 문제이다
  - [이곳](https://co-da-nam.tistory.com/30)을 참고했다
  - 2차원 평면에서 y값을 기준으로 포함되는 사각형을 구했다
  - y값 = 기울기 * x값으로 산출되는데 사각형 하나당 길이1인 사각형이기에 값이 5.67777이 나온다면 5개의 사각형만 포함이고 나머지 0.6777은 사선이 지나가는 값이 된다.
  - 이를 x의 길이 만큼 반복하면 사선 한쪽의 사각형 갯수를 구하게 되고 나머지 반대편도 대칭이기에 *2하여 값을 반환한다



### 사고개념

- [124 나라의 숫자](https://github.com/vvvvvoin/SWcoding/blob/master/src/programers_Lv2/Exam00.java)
- [문제](https://programmers.co.kr/learn/courses/30/lessons/12899)
  - n진법에 대한 문제이다
  - 10진법으로 입력을 넣었을때 해당 문제의 124나라의 진법에 맞게 변환해야한다.



### String

- [스킬트리](https://github.com/vvvvvoin/SWcoding/blob/master/src/programers_Lv2/Exam01.java)

- [문제](https://programmers.co.kr/learn/courses/30/lessons/49993)
  - 스킬트리가 스킬의 순서에 맞게 된 경우를 리턴하는 문제이다
  - 스킬은 skill에 존재하는 문자 순서대로 찍혀야한다. 그외 문자는 상관이 없다
  - 그러므로 skill_trees에 있는데 문자를 분해해서 하나씩 indexOf로 비교한다 만약 skill에 존재하는 경우 0 부터 시작하는 index와 비교한다.
  - 만약 인덱스가 일치하면 1씩 카운트하여 다음문자열과 계속검사한다.
  - index가 맞지 않다면 flag 변수와 함께 break하도록 한다.



### Class

- [프린터](https://github.com/vvvvvoin/SWcoding/blob/master/src/programers_Lv2/Exam05.java)
- [문제](https://programmers.co.kr/learn/courses/30/lessons/42587)
  - 일반적인 프린터와 다르게 우선순위가 높은게 큐에 존재한다면 다시 큐에 넣고 아닐경우를 출력한다
  - 그리고 초기 배열의 인덱스(location)이 몇번째 나왔는지 출력하는 문제이다.
  - 우선순위 값과, 초기 인덱스를 담을 수 있는 클래스를 만든다.
  - 처음 priorities 배열을 클래스 변수로 만들어 queue를 만들어 준다.
  - 그리고 하나의 값을 빼서 tempQueue를 만들어 queue값과 비교해서 우선순위가 가장높은지 확인한다
  - 만약 가장 높다면 arrayList에 값을 담는다
  - 만약 해당 값보다 높은 값이 있다면 다시 queue에 넣고 반복한다.
  - 반복 후 arrayList에는 가장먼저 나온 순으로 저장되고 해당 값에는 초기 index를 포함하고 있다. 값을 꺼내 index값과 location과 비교하여 같은 값을 반환시키면 몇번째로 나왔는지 알 수 있다.



### DFS

- [카카오프렌즈 컬러링북](https://github.com/vvvvvoin/SWcoding/blob/master/src/programers_Lv2/Exam08.java)
- [문제](https://programmers.co.kr/learn/courses/30/lessons/1829)
  - 배열에 채색된 색 종류 중 가장 많이 채색된 칸과 색의 모든 영역을 리턴하는 문제이다
  - 해당 문제를 풀기위해 시작하는 영역부터 탐색할 곳을 저장할 스택과 해당 칸을 검사했는지 입력과 같은 사이즈의 boolean 배열이 필요하다
  - 또한 계산에 편히가이 위해 x, y의 방향을 담을 클래스를 만든다
  - dfs메소드를 시작하는 기준은 해당값이 0이 아니고 방문한적이 없는 경우로 시작하고 이 경우를 카운트 하면 색의 영역의 수를 구할 수 있다
  - 배열0,0 부터 시작하여
    - stack에 넣기
    - boolean의 값을 true변경
    - stack이 비어질 동안 stack.poll 하여 해당값 기준으로 상하좌우에 대해 배열범위가 초과하는지와 현재값과 다음값이 일치하는지 확인한다
    - 일치한다면 다음값을 스택에 넣고 비교값을 카운터 후 반복
  - 해당 DFS 메소드의 카운터 값을 가장많이 채색된 값을 구한다



### 사고개념

- [큰 수 만들기](https://github.com/vvvvvoin/SWcoding/blob/master/src/programers_Lv2/Exam10.java)

- [문제](https://programmers.co.kr/learn/courses/30/lessons/42883)
  - 입력 K개수 만큼의 수를 제거하여 가장 큰 수를 만든는 문제이다
  - 입력의 크기 - k 를 하면 몇자리수의 정답이 나올지 알 수 있다
  - number .length - k번 만큼 반복한다
    - index 0 부터 시작하여 k+n번 index까지의 입력의 수중 가장 큰값을 찾는다
      - 이 의미는 정답으로 만약 4자리가 나온다면 처음에는 적어도 4자리수, 5자리수... N자리수 이상에 숫자중 가장 큰 값을 찾아야 한다는 의미이다.
    - 최대값을 찾게되면 다시 시작하는 index는 찾은수의 인덱스 + 1에서 다시 찾게된다
    - 그리고 다음 찾는 범위는 1, 2, 3, 4, ...씩 증가하며 다음 자릿수를 찾으면된다


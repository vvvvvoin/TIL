### Index

- 인덱스는 테이블의 동작속도를 높여주는 자료구조이다.
- 일반적으로 B-Tree구조를 가지고 있다.
- 검색에는 큰 효율을 나타내지만 삭제와 삽입에는 성능이 떨어지게 된다.

#### 왜 B-tree?

- 만일 링크드 리스트를 이용하여 인덱스를 구현한다고 하면 데이터를 찾기 위한 시간은 O(N)일 것이다.
- 또한 데이터의 크기가 커질수록 찾고자 하는 시간을 커질 것이다.
- 하지만 이를 Tree형태로 만든다면 성능은 O(logN)으로 될것이다.
- 그렇지만 한쪽으로 노드가 몰린 구조라면 최악의 경우인 O(N)의 시간 복잡도를 가질 것이다.
- 그래서 Balanced Tree 를 이용하여 인덱스를 구현하는 것이다.

#### 주의사항

- 동작속도를 높여주지만 많이 쓰면 성능이 떨어질 수 있다.
  - 인덱스는 DB메모리를 사용하여 테이블형태로 저장되므로 개수와 저장공간이 비례한다.
- 그렇기 때문에 교유한 값이면서 자주 조회하는 값을 index로 설정해준다.

- DML에 어떤 영향을 끼칠까?
  - 일반적으로 `SELECT, UPDATE, DELETE`에서는 성능이 잘나오지만
  - `INSERT`를 수행하면 기존 인덱스 페이지에 저장되어 위치를 탐색하고 수정하는 과정에서 효율이 좋지 않다.
    - 즉 `INSERT`가 자주 있는 테이블이면 INDEX를 설정시 주의해야한다.

### 격리수준

#### 레벨0 Read Uncommited

- 트랜잭션A가 SELECT한 후 트랜잭션B가 SELECT후 트랜잭션A가 내용을 UPDATE하고 트랜잭션B가 다시 SELECT하면 COMMIT되지 않고 변경된 데이터를 읽게됨

- Dirty Read, Nonrepeatable Read, Phantom Read 현상 발생

#### 레벨1 Read Commited

- 트랜잭션 A가 SELECT한 후 태른잭션B가 SELECT후 트랜잭션 A가 내용을 UPDATE하고 COMMIT한 후 트랜잭션B는 이전 내용이 아닌 변경된 내용을 읽게됨
- 하나의 트랜잭셔내에서 똑같은 SELECT 쿼리를 실행했을 때 같은 같이 출력되지 않음

- Nonrepeatable Read, Phantom Read 현상 발생

#### 레벨2 Repeatable Read

- 각 트랜잭션마다 트랜잭션ID를 부여하여 자신보다 작은 트랜잭션에서 변경된 것만 읽게한다.
- Phantom Read 현상 발생
  - 트랜잭션1이 A테이블에서 SELECT한 이후 트랜잭션2에서 A테이블에 내용을 추가/삭제(INSERT/UPDATE)하는 상황 가정
  - Repeatable Read가 보장된 경우, A테이블에서 SELECT해왔던 데이터들을 다른 트랜잭션2가 수정(UPDATE)하여 commit한 후 트랜잭션1에서 다시 A테이블을 SELECT 하더라도 트랜잭션2의 수정내용을 읽어들일 수 없다.
  - 하지만 트랜잭션2가 추가/삭제(INSERT/DELETE)를 한 경우, 다시 A 테이블에서 SELECT하게되면 기존에 A에서 SELECT했던 데이터에서 row가 추가되거나 사라질 수 있다.

#### 레벨3 Serialiazble

- 정합성 에러가 없는 검격한 격리수준

### 정규화

- 한 릴레이션에서 여러 엔티티의 속성이 혼합하게 되면 정보가 중복저장된다.
- 저장공간이 낭비되고 `갱신이상`이 발생한다.
- 갱신이상 - 삽입, 삭제, 수정연산 중 삽입되지 않거나, 튜플전체가 삭제되거나 일부 튜플만 갱신되는 일관성이 없어지는 형상이다.
- 그래서 데이터 중복을 최소화하기 위해 정규화를 하게 된다.

#### 제 1정규형 (도메인 원자값)

- 도메인이 오직 원자값만을 포함하고, 튜플의 모든 속성이 도메인에 속하는 값을 가져야 한다.

#### 제 2정규형 (부분적 함수종속 제거)

- 모든 비주요 속성들이 주요 속성에 대해서 완전 함수적 종속관계이다.

#### 제 3정규형 (이행 함수종속 제거)

- 어떠한 비주요 속성들이 기본키에 대해서 이행적으로 종속되지 않는다.

#### BCNF 정규형 (결정자이면서 후보키가 아닌 것 제거)

- 어떠한 비주요 속성들이 후보키의 일부를 결정하는 분해과정

#### 장점

- 결과적으로 각종 이상현상 문제를 해결한다.

#### 단점

- 릴레이션이 분해됨에 따라 JOIN연산이 많아저 성능이 낮아질 수 있다.
- 이를 반정규화로 데이터의 중복 및 통합으로 성능을 향상시킨다.

### 트랜잭션 무결성

- 원자성 - 트랜잭션은 모두 반영되거나 취소되어야 한다.
- 독립성 - A라는 트랜잭션이 작업중일때 B트랜잭션이 관여할 수 없다.
- 일관성 - 트랜잭션 이후 DB의 상태가 유지되어야 한다.
- 영속성 - 반영된 결과는 DB에 문제가 생기더라도 영구적으로 반영된다.


# 저장 서브프로그램

- 저장 서브프로그램은 필요할 때마다 실행할 수 있는 PL/SQL이다

## 저장 서브프로그램

### 저장 서브프로그램이란?

- 이전에는 PL/SQL 블록은 단 한 번 실행하는데 사용하였다.
- 이런 블록을 이름이 정해져 있지 않은 PL/SQL 블록이라는 의미로 익명 블록이라고 한다.
- 익명 블록은 오라클에 저장되지 않기 때문에 한 번 실행한 뒤에 다시 실행하려면 PL/SQL 블록을 다시 작성하여 실행해야한다.
- 그런데 PL/SQL로 만든 프로그램을 주기적으로 또는 필요할 때마다 여러 번 사용해야 하는 상황이 빈번히 발생한다.
- 이럴 경우에 PL/SQL 프로그램을 오라클에 저장해 두면 필요할 떄마다 수행할 내용을 작성하지 않고 실행할 수 있으므로 편리하다.
- 이렇게 여러번 사용할 목적으로 이름을 지정하여 오라클에 저장해 두는 PL/SQL프로그램을 저장 서브프로그램이라고 한다.
- 익명블록과 달리 저장 서브프로그램은 오라클에 저장하여 공유할 수 있으므로 메모리, 성능, 재사용 등 여러 면에서 장점이 있다.
- 오라클에서는 용도에 따라 여러 가지 방식으로 저장 서브프로그램을 구현할 수 있다.
  - 저장 프로시저 : 일반적으로 특정 처리 작업 수해응ㄹ 위한 서브 프로그램으로 SQL문에서는 사용할 수 없다.
  - 저정 함수 : 일반적으로 특정 연산을 거친 결과 값을 반환하는 서브 프로그램으로 SQL문에서 사용할 수 있다.
  - 패키지 : 저장 서브 프로그램을 그룹화하는 데 사용한다.
  - 트리커 : 특정 상황이 발생할 때 자동으로 연달아 수행할 기능을 구현하는 데 사용한다.

## 프로시저

- 저장 프로시저는 특정 처리 작업을 수행하는 데 사용하는 저장 서브 프로그램으로 용도에 따라 파라미터를 사용할 수 있고 사용하지 않을 수 있다.

### 파라미터를 사용하지 않는 프로시저

#### 프로시저 생성하기

- 작업 수행에 따라 별다른 입력 데이터가 필요하지 않을 경우에 파라미터를 사용하지 않는 프로시저를 사용한다.
- 다음과 같은 형식으로 만들게 된다.

```SQL
CREATE [OR REPLACE] PROCEDURE 프로시저이름
IS | AS
	선언부
BEGIN
	실행부
EXCEPTION
	예외 처리부
END [프로시저이름];
```

``` SQL
CREATE OR REPLACE PROCEDURE pro_noparam
IS
	V_EMPNO NUMBER(4) := 7788;
	V_ENAME VARCHAR2(10);
BEGIN
	V_ENAME := 'SCOTT';
	DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
	DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/
```

- 위와 같이 프로시저를 생성 후 다음과 같이 프로시저를 실행할 수 있다.

```sql
EXECUTE 프로시저이름
EXECUTE pro_noparam
```

#### PL/SQL 블록에서 프로시저 실행하기

- 특정 PL/SQL블록에서 이미 만들어져 있는 프로시저를 실행한다면 다음과 같이 사용할 수 있다.

```SQL
BEGIN
	프로시저 이름;
END;
```

- 익명 블록에서 pro_noparam 프로시져를 실행해 본다.

```SQL
BEGIN
	pro_noparam;
END;
/
```

#### 프로시저 내용 확인하기

- 이미 저장되어 있는 프로시저를 포홤하여 서브 프로그램의 소스 코드 내용을 확인하려면 USER_SOURCE 데이터 사전에서 조회할 수 있다.
- USER_SOURCE 열
  - NAME : 서브 프로그램 이름
  - TYPE : 서브 프로그램 종류 (프로시저, 함수 등)
  - LINE : 서브 프로그램에 작성한 줄 번호
  - TEXT : 서브 프로그램에 작성한 소스 코드

```SQL
SELECT *
FROM USER_SOURCE
WHERE NAME = 'PRO_NOPARAM';
```

#### 프로시저 삭제하기

- DROP PROCEDURE 명령어로 프로시저를 삭제할 수 있다.

```SQL
DROP PROCEDURE PRO_NOPARAM;
```

### 파라미터를 사용하는 프로시저

- 프로시저를 실행하기 위해 입력 데이터가 필요한 경우에 파라미터를 정의할 수 있다.

```SQL
CREATE [OR REPLACE] PROCEDURE 프로시저이름
[(파라미터 이름 [MODES] 자료형 [:= | DEFAULT 기본값],
  파라미터 이름 [MODES] 자료형 [:= | DEFAULT 기본값]
)]
IS | AS
	선언부
BEGIN
	실행부
EXCEPTION
	예외 처리부
END [프로시저 이름];
```

- 파라미터를 지정할 때 사용하는 모드는 IN, OUT, IN OUT 세 가지가 있다.
- 각 모드 지정에 따른 파라미터 지정방식은 다음과 같다.
  - IN : 지정하지 않으면 기본값으로 프로시저를 호출할 때 값을 입력받는다.
  - OUT : 호출할 때 값을 반환한다
  - IN OUT : 호출할 때 ㄱ밧을 입력받은 후 실행 결과 값을 반환한다.

####  IN 모드 파리미터

- 프로시저 실행에 필요한 값을 직접 입력받는 형식의 파라미터를 지정할 때 IN을 사용한다.
- IN은 기본값이기 때문에 생략 가능하다.

```SQL
CREATE OR REPLACE PROCEDURE pro_param_in
(
    param1 IN NUMBER,
    param2 NUMBER,
    param3 NUMBER := 3,
    param4 NUMBER DEFAULT 4
)
IS

BEGIN
	DBMS_OUTPUT.PUT_LINE('param1 : ' || param1);
	DBMS_OUTPUT.PUT_LINE('param2 : ' || param2);
	DBMS_OUTPUT.PUT_LINE('param3 : ' || param3);
	DBMS_OUTPUT.PUT_LINE('param4 : ' || param4);
END;
/
```

- 파라미터 네 개를 지정하고 param3, 4에는 기본 값을 지정하는 코드이다.

- 지정된 파라미터가 네 개이므로 실행할 때 다음과 같이 네 개 값을 지정하여 실행할 수 있다.

```SQL
EXECUTE pro_param_in(1, 2, 9, 8);
```

- 파라미터 param3, 4는 기본값이 지정되어 있는 상태이므로 호출할 때 값을 지정하지 않아도 실행이 가능하다.
- 다음과 같이 두 개 값만 지정하여 프로시저를 실행하면 기본값이 지정된 param3, 4는 기본값이 출력되고 두 값은 param1, 2파라미터 순서대로 입력된다.

```SQL
EXECUTE pro_param_in(1, 2);
```

- param1, 2파라미터는 기본값이 지정되어 있지 않다.
- 만약 해당 프로시저를 호출할 때 기본값이 지정되지 않은 파라미터 수보다 적은 수의 값을 지정하면 프로시저 실행은 실패한다.

- 만약 기본값이 지정된 파라미터와 지정되지 않은 파라미터 순서가 섞여 있다면 기본값이 지정되지 않은 파라미터까지 값을 입력해줘야한다.
- 다음과 같은 경우 파라미터를 최소 세 개를 입력해야한다.

```SQL
param1 IN NUMBER,
param2 NUMBER := 3,
param3 NUMBER,
param4 NUMBER DEFAULT 4
```

- 하지만 파라미터 종류나 개수가 많아지면 이러한 방식은 불편할 수 있다.
- 그래서 다음과 같이 => 를 사용하여 파라미터 이름에 직접 값을 대입하는 방식도 사용한다.

```SQL
EXECUTE pro_param_in(param1 => 10, param2 => 20);
```

#### OUT 모드 파라미터

- OUT 모드를 사용한 파라미터는 프로시저 실행 후 호출한 프로그램으로 값을 반환한다.
- 사원 번호를 입력받아 사원 이름과 급여를 반환하는 프로시저를 만들 수 있다.

```SQL
CREATE OR REPLACE PROCEDURE pro_param_out
(
    in_empno IN EMP.EMPNO%TYPE,
    out_ename OUT EMP.ENAME%TYPE,
    out_sal OUT EMP.SAL%TYPE
)
IS

BEGIN
	SELECT ENAME, SAL INTO out_ename, out_sal
	FROM EMP
	WHERE EMPNO = in_empno;
END pro_param_out;
/
```

- OUT 모드로 지정한 두 파라미터 out_ename, out_sal은 pro_param_out 프로시저를 실행한 후 값이 반환된다.
- 이렇게 반환되는 값을 다음과 같이 또 다른 PL/SQL 블록에서 받아서 처리할 수 있다.

```SQL
DECLARE
	v_ename EMP.ENAME%TYPE;
	v_sal EMP.SAL%TYPE;
BEGIN
	pro_param_out(7788, v_ename, v_sal);
	DBMS_OUTPUT.PUT_LINE('v_ename : ' || v_ename);
	DBMS_OUTPUT.PUT_LINE('v_sal : ' || v_sal);
END;
/
```

- 변수 두 개를 선언하여 프로시저의 반환 값에 대입하게 된다.

#### IN OUT 모드 파라미터

- IN OUT 모드로 선언한 파라미터는 IN, OUT 으로 선언한 파라미터 기능을 동시에 수행한다.
- 즉 값을 입력받을 때와 프로시저 수행 후 결과 값을 반환할 때 사용한다.

```SQL
CREATE OR REPLACE PROCEDURE pro_param_inout
(
    inout_no IN OUT NUMBER
)
IS

BEGIN
	inout_no := inout_no * 2;
END pro_param_inout;
/
```

- OUT 모드로 선언된 파라미터와 같이 IN OUT 모드로 선언된 파라미터 역시 다른 PL/SQL블록에서 선언된 변수에 대입하여 사용할 수 있다.

```SQL
DECLARE
	no NUMBER;
BEGIN
	no := 5;
	pro_param_inout(no);
	DBMS_OUTPUT.PUT_LINE('no : ' || no);
END;
/
```

### 프로시저 오류 정보 확인하기

- 프로시저를 생성하는 과정에서 발생된 오류를 SHOW ERRORS명령어와 USER_ERROS 테이터 사전을 조회하여 사용할 수 있다.

#### SHOW ERRORS로 오류 확인

- 가장 최근에 생성되거나 변경된 서브프로그램 오류 정보를 출력한다.

```SQL
SHOW ERRORS;
```

- SHOW ERRORS 명령어는 줄여서 SHOW ERR로 사용할 수 있다.
- 최근에 발생한 오류가 아닌 특정 프로그램에서 발생한 오류를 확인하고 싶다면 다음과 같이 사용한다.

```SQL
SHOW ERR 프로그램 종류 프로그램 이름
SHOW ERR PROCEDURE pro_err;
```

#### USER_ERRORS로 오류확인

- USER_ERRORS 데이터 사전을 조회하여 오류 정보를 확인할 수 있다.

```SQL
SELECT *
FROM USER_ERRORS
WHERE NAME = 'PRO_ERR';
```

## 함수

- 오라클 함수는 크게 내장함수와 사용자 정의 함수로 분류할 수 있다.
- PL/SQL를 사용하여 함수를 직접 정의하는 방법을 알아본다.
- 함수 제작 방식은 먼저 살펴본 프로시저와 제작 방식이 유사하다.

### 함수 생성하기

- 함수 생성은 프로시저와 마찬가지로 CREATE [OR REPLACE] 명령어와 FUNCTION키워드를 명시하여 생성한다.
- 프로시저와 다르게 함수는 반환 값의 자료형과 실행부에서 반환할 값을 RETURN절 및 RETURN문으로 명시해야한다.

```SQL
CREATE [OR REPLACE] FUNCTION 함수이름
[(파라미터 이름 [IN] 자료형,
  파라미터 이름 [IN] 자료형,
)]
RETURN 자료형
IS | AS
	선언부
BEGIN
	실행부
	RETURN (반환 값);
EXCEPTION
	예외 처리부
END [함수 이름];
```

```SQL
CREATE OR REPLACE FUNCTION func_aftertax(
	sal IN NUMBER
)
RETURN NUMBER
IS
	tax NUMBER := 0.05;
BEGIN
	RETURN (ROUND(sal - (sal * tax)));
END func_aftertax;
/
```

### 함수 실행하기

- 생성된 함수는 익명 블록 또는 프로시저 같은 저장 서브프로그램, SQL문에서 사용할 수 있다.
- PL/SQL로 실행할 때는 함수 반환 값을 대입받을 변수가 필요하다.

#### PL/SQL로 함수 실행하기

- 함수는 실행 후 하나의 값을 반환하므로 PL/SQL로 구현한 프로그램안에 반환 값을 받기 위한 변수를 선언하여 사용한다.

```SQL
DECLARE
	aftertax NUMBER;
BEGIN
	aftertax := func_aftertax(3000);
	DBMS_OUTPUT.PUT_LINE('aftertax : ' || aftertax);
END;
/
```

#### SQL문에서 함수 실행하기

- SQL문에서 제작한 함수를 사용하는 방ㅅ기은 기존오라클 내장함수와 같다.

```SQL
SELECT func_aftertax(3000)
FROM DUAL;
```

- 함수에 정의한 파라미터와 자료형이 일치한다면 내장 함수와 마찬가지로 특정 열 또는 열 데이터 간에 연산 가공된 데이터를 입력하는 것도 가능하다.

```SQL
SELECT EMPNO, ENAME, SAL, func_aftertax(SAL) AS AFTERTAX
FROM EMP;
```

### 함수 삭제하기

- 다른 객체와 마찬가지로 DROP FUNCTION명령어로 함수를 삭제한다.

```SQL
DROP FUNCTION func_aftertax;
```

## 패키지

- 패키지는 업무나 기능 면에서 연관성이 높은 프로시저, 함수 등 여러 개의 PL/SQL 서브프로그램을 하나의 논리 그룹으로 묶어 통합, 관리하는 데 사용하는 객체를 뜻한다.
- 패키지를 사용하여 서브프로그램을 그룹화하면 몇가지 장점이 존재한다.
  - 모듈성
  - 쉬운 응용 프로그램 설계
  - 정보 은닉
  - 기능성, 성능 향상

### 패키지 구조와 생성

- 패키지는 프로시저, 함수와 달리 보통 두 부분 명세, 본문으로 나뉜다.

#### 패키지 명세

- 패키지 명세는 패키지에 포함할 변수, 상수, 예외, 커서 그리고 PL/SQL 서브프고르매을 선언하는 용도로 작성한다.
- 패키지 명세에 선언한 여러 객체는 패키지 내부뿐만 아니라 외부에 서도 참조할 수 있다.

```SQL
CREATE [OR REPLACE] PACKAGE 패키지이름
IS | AS
	서브프로그램을 포함한 다양한 객체 선언
END 패키지이름;
```

```SQL
CREATE OR REPLACE PACKAGE pkg_example
IS 
	spec_no NUMBER := 10;
	FUNCTION func_aftertax(SAL NUMBER) RETURN NUMBER;
	PROCEDURE pro_emp(in_empno IN EMP.EMPNO%TYPE);
	PROCEDURE pro_dept(in_deptno IN DEPT.DEPTNO%TYPE);
END;
/
```

- 이미 생성되어 있는 패키지 명세의 코드를 확인하거나 선언한 서브프로그램을 확인하려면 USER_SOURCE 데이터 사전을 조회하거나 DESC 명령어를 활용할 수 있다.

```SQL
SELECT TEXT
FROM USER_SOURCE
WHERE TYPE = 'PACKAGE'
AND NAME = 'PKG_EXAMPLE';
```

#### 패키지 본문

- 패키지 본문에는 패키지 명세에서 선언한 서브 프로그램 코드를 작성한다.
- 패키지 명세에 선언하지 않은 객체나 서브 프로그램을 정의하는 것도 가능하다.
- 이때 패키지 본문에만 존재하는 프로그램은 패키지 내부에서만 사용할 수 있다.
- 패캐지 본문 이름은 패키지 명세 이름과 같게 지정해야한다.

```SQL
CREATE [OR REPLACE] PACKAGE BODY 패키지 이름
IS | AS
	패키지 명세에서 선언한 서브 프로그램을 포함한 여러 객체를 정의
	경우데 따라 패키지 명세에 존재하지 않는 객체 및 서프 프로그램도 정의가능
END 패키지이름;
```

- pkg_example 패키지 본문을 다음과 같이 작성할 수 있다.
- 본문에서는 패키지 명세에 선언한 함수와 프로시저를 기술하고 body_NO변수를 선언한다.

```SQL
CREATE OR REPLACE PACKAGE BODY pkg_example
IS
	body_no NUMBER := 10;
	
	FUNCTION func_aftertax(sal NUMBER) RETURN NUMBER
	IS
		tax NUMBER := 0.05;
	BEGIN
		RETURN (ROUND(sal - (sal * tax)));
	END func_aftertax;
	
	PROCEDURE pro_emp(in_empno IN EMP.EMPNO%TYPE)
	IS
		out_ename EMP.ENAME%TYPE;
		out_sal EMP.SAL%TYPE;
	BEGIN
		SELECT ENAME, SAL INTO out_ename, out_sal
		FROM EMP
		WHERE EMPNO = in_empno;
		DBMS_OUTPUT.PUT_LINE('out_ename : ' || out_ename);
		DBMS_OUTPUT.PUT_LINE('out_sal : ' || out_sal);
	END pro_emp;
	
	PROCEDURE pro_dept(in_deptno IN DEPT.DEPTNO%TYPE)
	IS
		out_dname DEPT.DNAME%TYPE;
		out_loc DEPT.LOC%TYPE;
	BEGIN
		SELECT DNAME, LOC INTO out_dname, out_loc
		FROM DEPT
		WHERE DEPTNO = in_deptno;
		DBMS_OUTPUT.PUT_LINE('out_dname : ' || out_dname);
		DBMS_OUTPUT.PUT_LINE('out_loc : ' || out_loc);
	END pro_dept;
END;
/
```

#### 서브프로그램 오버로드

- 일반적으로 서브 프로그램 이름은 붕복될 수 없다.
- 하지만 같은 패키지에서 사용하는 파라미터의 개수, 자료형, 순서가 다를 경우 한해서만 이름이 같은 서브 프로그램을 정의할 수 있다.
- 이를 서브 프로그램 오버로드라 한다.
- 서브프로그램 오버로드는 같은 기능을 수행하는 여러 서브프로그램이 입력 데이터를 각각 다르게 정의할 때 사용한다.
- 또한 서브 프로그램 종류가 같아야 오버로드가 가능하다.
- 즉 특정 프로시저를 오버로드할 때 반드시 이름이 같은 프로시저로 정의해야한다.

```SQL
CREATE OR REPLACE PACKAGE pkg_overload
IS
	PROCEDURE pro_emp(in_empno IN EMP.EMPNO%TYPE);
	PROCEDURE pro_emp(in_ename IN EMP.ENAME%TYPE);
END;
/
```

```SQL
CREATE OR REPLACE PACKAGE BODY pkg_overload
IS
	PROCEDURE pro_emp(in_empno IN EMP.EMPNO%TYPE)
	IS
		out_ename EMP.ENAME%TYPE;
		out_sal EMP.SAL%TYPE;
	BEGIN
		SELECT ENAME, SAL INTO out_ename, out_sal
		FROM EMP
		WHERE EMPNO = in_empno;
		DBMS_OUTPUT.PUT_LINE('out_ename : ' || out_ename);
		DBMS_OUTPUT.PUT_LINE('out_sal : ' || out_sal);
	END pro_emp;
	
	PROCEDURE pro_emp(in_ename IN EMP.ENAME%TYPE)
	IS
		out_ename EMP.ENAME%TYPE;
		out_sal EMP.SAL%TYPE;
	BEGIN
		SELECT ENAME, SAL INTO out_ename, out_sal
		FROM EMP
		WHERE ENAME = in_ename;
		DBMS_OUTPUT.PUT_LINE('out_ename : ' || out_ename);
		DBMS_OUTPUT.PUT_LINE('out_sal : ' || out_sal);
	END pro_emp;
END;
/
```

### 패키지 사용하기

- 패키지를 통해 그룹화된 변수, 상수, 예외, 커서, PL/SQL서브 프로그램은 패키지 이름과 마침표와 사요할 객체이름으로 사용할 수 있다.

```SQL
BEGIN
	DBMS_OUTPUT.PUT_LINE('PKG_EXAMPLE.FUNC_AFTER(3000)');
	DBMS_OUTPUT.PUT_LINE('AFTER-TAX : ' || pkg_example.func_aftertax(3000));
	
	DBMS_OUTPUT.PUT_LINE('PKG_EXAMPL.PRO_EMP(7788)');
	pkg_example.pro_emp(7788);
	
	DBMS_OUTPUT.PUT_LINE('PKG_EXAMPL.PRO_DEPT(10)');
	pkg_example.pro_dept(10);
	
	DBMS_OUTPUT.PUT_LINE('PKG_OVERLOAD.PRO_EMP(7788)');
	pkg_overload.pro_emp(7788);
	
	DBMS_OUTPUT.PUT_LINE('PKG_OVERLOAD.PRO_EMP(''SCOTT'')');
	pkg_overload.pro_emp('SCOTT');
END;
/	
```

### 패키지 삭제하기

- 두가지 방식을 사용하여 패키지를 삭제할 수 있다.
- 패키지 명세와 본문을 한 번에 삭제하거나 패키지 본문만 삭제할 수도 있다.
- 하지만 패키지에 포함된 서브프로그램을 따로 삭제하는 것은 불가능하다.
- CREATE OR REPLACE문을 활용하여 패키지 안에 객체 또는 서프 프로그램을 수정 및 삭제할 수 있다.

```SQL
패키지 명세와 본문을 한 번에 삭제하기
DROP PACKAGE 패키지 이름;

DROP PKCKAGE BODY 패키지 이름;
```

## 트리거

### 트리거란?

- 오라클에서 트리거는 DB안의 특정 상황이나 동작, 즉 이벤트가 발생할 겨웅에 자동으로 실행되는 기능을 정의하는 PL/SQL 서브 프로그램이다.
- 하지만 트리거는 특정 작업 또는 이벤트 발생흐오 다른 데이터 작업을 추가로 실행하기 때문에 무분별하게 사용하면 DB성능을 떨어 뜨리는 원인이 되므로 주의가 필요하다.

### DML 트리거

#### DML 트리거 형식

- DML트리거는 특정 테이블에 DML 명령어를 실행 했을 때 작동하는 트리거이다.

```SQL
CREATE [OR REPLACE] TRIGGER 트리거이름
BEFOR | AFTER
IUNSERT | UPDATE | DELETE ON 테이블이름
REFERENCING OLD AS old | NEW as new
FOR EACH ROW WHEN 조건식
FOLLOWS 트리거이름2, ...
ENABLE | DISABLE

DECLARE
	선언부
BEGIN
	실행부
EXCEPTION
	예외 처리부
END;
```

### DML 트리거의 제작 및 사용(BEFORE)

- 트리거를 적용할 테이블을 생성한다.

```SQL
CREATE TABLE EMP_TRG
AS SELECT * FROM EMP;
```

- 생성된 EMP_TRG 테이블에 DML명령어를 실행하기 직전에 작동할 트리거를 다음과 같이 만든다.

```SQL
CREATE OR REPLACE TRIGGER trg_emp_nodml_weekend
BEFORE
INSERT OR UPDATE OR DELETE ON EMP_TRG
BEGIN
	IF TO_CHAR(sysdate, 'DY') IN ('토', '일') THEN
		IF INSERTING THEN
			raise_application_error(-2000, '주말 사원정보 추가 불가');
		ELSIF UPDATING THEN
			raise_application_error(-2000, '주말 사원정보 수정 불가');
		ELSIF DELETING THEN
			raise_application_error(-2000, '주말 사원정보 삭제 불가');
		ELSE
			raise_application_error(-2000, '주말 사원정보 변경 불가');
		END IF;
	END IF;
END;
/
```

- 이제 트리거가 작동하도록 EMP_TRG 테이블에 DML명령어를 사용해 본다.
- 트리거는 특정 이벤트가 발생할 때 자동으로 작동하는 서브 프로그램이므로 프로시저나 함수와 같이 EXECUTE또는  PL/SQL 블록에서 따로 실행하지 못한다.
- 이제 INSERT, UPDATE, DELETE문은 주말일 경우 실행되지 않는 것을 확인 할 수 있다.

### DML 트리거의 제작 및 사용(AFTER)

- 이번에는 DML 명령어가 실행된 후 작동하는  AFTER트리거를 알아본다.
- 트리거를 적용할 테이블을 하나 생성한다.

```SQL
CREATE TABLE EMP_TRG_LOG(
	TABLENAME VARCHAR2(10),
    DML_TYPE VARCHAR2(10),
    EMPNO NUMBER(4),
    USER_NAME VARCHAR2(30),
    CHANGE_DATE DATE
);
```

- EMP_TRG 테이블에 DML 명령어를 수행한 후 EMP_TRG_LOG 테이블에 EMP_TRG테이블 데이터의 변경 사항을 기록하는 트리거를 생성한다.

```SQL
CREATE OR REPLACE TRIGGER trg_emp_log
AFTER
INSERT OR UPDATE OR DELETE ON EMP_TRG
FOR EACH ROW

BEGIN
	IF INSERTING THEN
		INSERT INTO emp_trg_log	
		VALUES('EMP_TRG', 'INSERT', :new.empno, SYS_CONTEXT('USERENV', 'SESSION_USER'), sysdate);
	ELSIF UPDATING THEN	
		INSERT INTO emp_trg_log	
		VALUES('EMP_TRG', 'UPDATE', :old.empno, SYS_CONTEXT('USERENV', 'SESSION_USER'), sysdate);
	ELSIF DELETING THEN	
		INSERT INTO emp_trg_log	
		VALUES('EMP_TRG', 'DELETE', :old.empno, SYS_CONTEXT('USERENV', 'SESSION_USER'), sysdate);
	END IF;
END;
/	
```

- EMP_TRG 테이블에 DML 명령어를 사용한 후 EMP_TRG_LOG 테이블의 변화를 확인한다.

```SQL
INSERT INTO EMP_TRG
VALUES(9999, 'TestEmp', 'CLERK', 7788, TO_DATE('2018-03-03', 'YYYY-MM-DD'), 1200, NULL, 20);

COMMIT;
```

- INSERT문 실행 후 EMP_TRG_LOG테이블을 확인해 본다

```SQL
SELECT *
FROM EMP_TRG_LOG;
```

- 테이블에 추가된 것을 확인할 수 있다 이제 UPDATE문을 사용해 본다.

```SQL
UPDATE EMP_TRG
SET SAL = 1300
WHERE MGR = 7788;

COMMIT;
```

- SCOTT이 상급인 사원은 바로 전에 INSERT문을 통해 추가한 TESTEMP와 기존에 존해하고 있던 ADAMS이므로 두 사원의 급여 데이터가 변경되었다.
- 두 개 행이 DML문에 영향을 받았으므로 트리거에 지정한 FOR EACH ROW옵션으로 트리거는 두 번 실핸된다.

### 트리거 관리

#### 트리거 정보 관리

- 트리거 정보를확인하려면 USER_TRIGGERS 테이터 사전을 조회한다.

```SQL
SELECT TRIGGER_NAME, TRIGGER_TYPE, TRIGGERING_EVENT, TABLE_NAME, STATUS
FROM USER_TRIGGERS;
```

### 트리거 번경

- ALTER TRIGGER 명령어로 트리거 상태를 변경할 수 있다.
- 특정 트리거를 활성화 또는 비활성화하려면 ALTER TRIGGER 명령어에 ENALBE 또는 DISABLE 옵션을 지정한다.

```SQL
ALTER TRIGGER 트리거이름 ENALBE | DISABLE;
```

- 특정 테이블과 관련된 모든 트리거의 상태를 활성화하거나 비활성화하는 것도 가능하다

```SQL
특정 테이블과 관련된 모든 트리거의 상태 활성화
ALTER TABLE 테이블이름 ENABLE ALL TIRGGERS;

특정 테이브과 관련된 모든 트리거 상태 비활성화
ALTER TABLE 테이블이름 DISABLE ALL TRIGGER;
```

### 트리거 삭제

```SQL
DROP TRIGGER 트리거이름;
```


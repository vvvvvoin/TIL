# 트랜잭션 제어와 세션

## 하나의 단위로 데이터를 처리하는 트랜잭션

### 트랜잭션이란?

- 트랜잭션의 의미에 앞서 필요성에 대해 말한다.
- 만약 돈과 관련된 SQL문을 실행하는 과정에서 천재지변으로 수행된 일부 SQL문이 실행되지 않아 돈이 사라지는 결과가 나올 수 있다.
- 이런 상황을 막기위해서는 두 가지 방법이 있다
  - 어떤 상황이든 모든 SQL문을 완전히 실행하는 것
  - 위에 방법이 안될 경우 SQL문이 실행되기 전으로 되돌리는 것
- 따라서 SQL문은 하나의 실행 단위처럼 있어야 한다.
- 트랜잭션이란 더 이상 분할할 수 없는 최소 수행단위를 뜻하며 하나의 작업 또는 밀접하게 연관된 작업을 수행하기 위해 한 개 이상의 데이터 조작 명령어로 이루어진다.
- 즉 어떤 기능 한가지를 수행하는 SQL문 덩어리라 볼 수 있다
  - ex) A통장에서 돈을 꺼내고 해당 돈을 다시 B통장으로 이체시키는 일련에 모든 SQL문 덩어리
- 트랜잭션은 DB 계정을 통해 접속하는 동시에 시작된다.
- 트랜잭션이 종료되기 전까지 여러 SQL문을 실행하고 트랜잭션을 제어하는 명령을 실행할때 기존 트랜잭션은 끝난다.
- 그리고 새로운 트랜잭션이 시작된다.

## 트랜잭션을 제어하는 명령어

- 트랜잭션 개념을 통해 알 수 있듯이 하나의 트랜잭션에 묶여 있는 데이터 조작어의 수행 상태는
  - 모든 명령어가 정상적으로 수행 완료된 상태 
  - 모든 명령어가 수행되지 않아 취소된 상태
- 이 두 가지 상태로만 존재할 수 있다.
- 트랜잭션 제어 명령어는 데이터 조작 상태를 이 두 가지 상태 중 하나로 유도하는 명령어를 의미한다
- 즉 데이터 조작을 데이터베이스에 영구히 반영하거나 작업 전체를 취소한다.
- 트랜잭션 제어 명령어를 사용하는 DEPT_TCL 테이블을 만든다

```SQL
CREATE TABLE DEPT_TCL
AS SELECT *
	FROM DEPT;
	
SELECT * FROM DEPT_TCL;
```

- 생성된 테이블에 다음 명령어를 실행하고 확인한다.

```SQL
INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', 'SEOUL');
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;
DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';

SELECT * FROM DEPT_TCL;
```

### 트랜잭션을 취소하고 싶을 때는 ROLLBACK

- 위 예제에서 실행한 세 개의 데이터 조작어는 중간에 별다른 작업이 없었다면 하나의 트랜잭션에 속해 있을 것이다.
- 이 모든 작업의 수행을 취소하고 싶다면 ROLLBACK 명령어를 사용한다.
- ROLLBACK은 현재 트랜잭션에 포함된 데이터 조작 관련 명령어의 수행을 모두 취소한다.

```SQL
ROLLBACK;
```

- ROLLBACK명령어를 수행하면 기존의 데이터가 복구된다.

### 트랜잭션을 영원히 반영하고 싶을 떄는 COMMIT

- ROLLBACK가 달리 지금까지 수행한 트랜잭션 명령어를 데이터베이스에 영구히 반영할 때는 COMMIT 명령어를 사용한다.
- 다음 명령어를 실행 후 COMMIT을 실행해본다

```SQL
INSERT INTO DEPT_TCL VALUES(50, 'NETWORK', 'SEOUL');
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 20;
DELETE FROM DEPT_TCL WHERE DEPTNO = 40;

SELECT * FROM DEPT_TCL;

COMMIT;
```

- COMMIT명령어는 지금까지 트랜잭션에서 데이터 조작 관련 명령어를 통해 변경되누 데이터를 모두 데이터베이스에 영구히 반영한다.
- ROLLBACK 명령어로도 취소가 불가능하므로 COMMIT은 트랜잭션 작업이 정상적으로 수행되었다고 확신할때 사용해야한다.

#### DDL, DML?

- 첫 예제를 수행하면서 테이블을 만들고 테이블 데이터를 수정 후 ROLLBACK시켰는데 테이블 생성 명령은 취소되지 않았다
- 이 차이는 Data Definition Language(DDL), Data Manipulation Language(DML)에 있다
- DDL의 명령어는 실행되는 동시에 자동으로 COMMIT이 실행되어 복구될 수 없다
- DML 명령어는 사용자가 ROLLBACK, COMMIT을 하기전까지 현재 트랜잭션에 쌓이게 된다.
- DDL명령어는 데이터 구조를 변경하는 명령어들이다
  - CREATE TABLE : 테이블 생성
  - DROP TABLE : 테이블 삭제
  - ALTER TRABLE : 테이블 컬럼, 수정, 조건 수정
  - TRUNCATE : 테이블 구조를 남기고 모든 행 삭제
  - RENAME : 이름 변경
- DML명령어는 데이터를 조작할때 사용하는 명령어들이다
  - SELECT
  - UPDATE
  - DELETE
  - INSERT

- 추가적으로 DCL, DATA CONTROL LANGUAGE는 다음 명령어들이 있다
  - COMMIT
  - ROLLBACK
  - GRANT
  - REVOKE

## 세션과 읽기 일관성의 의미

### 세션이란?

- 세션이란 오라클 DB에 접속을 시작으로 DB에서 관련 작업을 수행한 후 접속을 종료하기전까지의 전체 기간을 의미한다.
- 그러므로 세션이 여러 개라는 말은 현재 오라클DB에 접속하여 사용 중인 연결이 여러 개 있다는 뜻이다.
- 예를들어 TOAD를 사용하여 오라클 DB에 접속하거나, 명령 프롬프트를 통해 접속하는 경우 세션이 두 개가 됩니다.
- 트랜잭션은 데이터 조작 명령어가 모인 하나의 작업 단위를 뜻하며 세션 내부에는 하나 이상의 트랜잭션이 존재한다.
- 왜냐하면 테이버베이스에 접속한 후 종료하기까지의 과정이 하나의 세션이고 이 세션이 유지되는 동안 COMMIT, ROLLBACK작업이 진행되기 대문이다.
- 세션은 트랜잭션보다 큰 개념이다.

### 읽기 일관성의 중요성

- 데이터베이스는 여러 곳에서 동시에 접근하여 데이터를 관리, 사용하는 것이 목적이므로 대부분 수많은 세션이 동시에 연결되어 있다.
- 읽기 일관성이란 어떤 특정 세션에서 테이블의 데이터를 변경 중일 떄 그 외 다른 세션에서는 데이터의 변경이 확정되기 전까지 변경 사항을 알 필요가 없으므로 데이터를 변경 중인 세션을 제외한 나머지 세션에서는 현재 진행 중인 변경과 무관한 본래의 데이터를 보여주는 특성을 의미한다.
- TOAD와 명령프롬프트를 이용하여 읽기 일관성에 대해 알아본다.

- 토드

  ```SQL
  SELECT * FROM DEPT_TCL;
  ```

- 명령프롬프트

  ```SQL
  SELECT * FROM DEPT_TCL;
  ```

- 같은 데이틀을 조회했기에 결과는 같을 것이다.

- 이제 TOAD세션에 테이터를 조작하고 확인해본다

- 토드

  ```SQL
  DELETE FROM DEPT_TCL
  WHERE DEPTNO = 50;
  
  SELECT * FROM DEPT_TCL;
  ```

- 명령프롬프트

  ```SQL
  SELECT * FROM DEPT_TCL;
  ```

- 명령프롬프트 SELECT결과에는 DEPTNO 50이 아직 삭제되지 않은 상태가 보여진다

- 즉 변경이 일어나기 전 상태가 출력된다.

- 이와 같이 어떤 데이터 조작이 포함된 트랜잭션이 완료되기 전까지 데이터를 직접 조작하는 세션 외 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회 출력 검색되는 특성을 읽기 일관성 이라고 한다.

- 이제 토드 센셔에 COMMIT을 실행 후 확인해 본다

- 토드

  ```SQL
  COMMIT; 
  
  SELECT * FROM DEPT_TCL;
  ```

- 명령프롬프트

  ```SQL
  SELECT * FROM DEPT_TCL;
  ```

- 이제 명렴프롬프트 세션에서도 삭제가 반영된 결과를 조회할 수 있게 된다.

- 하나의 DB에는 수많은 세션이 연결되고 각 세션에서는 데이터 조작 명령어가 포함된 여러 트랜잭션이 귾임없이 시작되고 종료되면서 실시간으로 작업이 수행된다.

- 데이터를 직접 변경 중인 해당 세션을 제외한 모든 세션은 다른 세션의 데이터 변경과 상관없이 이미 확정된 데이터만 검색됨으로써 읽기 일관성을 보장할 수 있다.

## 수정 중인 데이터 접근을 막는 LOCK

### LOCK이란?

- 특정 세션에서 조작중인 데이터는 트랜잭션이 완료되기 전까지 다른 세션에서 조작할 수 없는 상태가 된다.
- 즉 데이터가 잠기는 LOCK이 된다.
- LOCK은 조작중인 데이터를 다른 세션은 조작할 수 없도록 접근을 보류시키는 것을 뜻합니다.

### LOCK 개념

- 토드와 명령프롬프트로 개념을 알아본다.

- 토드

  ```SQL
  SELECT * FOME DEPT_TCL;
  ```

- 명령프롬프트

  ```SQL
  SELECT * FOME DEPT_TCL;
  ```

- 별다른 명령이 없었으면 같은 결과를 출력할 것이다.

- 토드세션 UPDATE문을 수행한다.

- 토드

  ```SQL
  UPDATE DEPT_TCL SET LOC = 'SEOUL'
  WHERE DEPTNO = 30;
  
  SELECT * FROM DEPT_TCL;
  ```

- 명령프롬프트

  ```SQL
  SELECT * FROM DEPT_TCL;
  ```

- UPDATE문을 실행하고 있는 토드세션에서는 LOC열의 데이터가 변경되었지만 명령프롬프트 세션에는 COMMIT을 하지 않았기에 변화가 없다.

- 이제 명령프롬프트에서 UPDATE문을 실행시킨다

- 명령프롬프트

  ```SQL
  UPDATE DEPT_TCL SET DNAME = 'DATABASE'
  WHERE DEPTNO = 30;
  ```

- 명령 프롬프트에는 명령어를 실행하면 아무런 동작이 일어나지 않는다.

- 이는 토드세션에서 30번 부서 데이터를 먼저 조작하고 있기 때문이다.

- 토드 세션에서 수행중인 30번 부서 행 데이터의 조작이 완료되지 않았기 때문에 COMMIT 도는 ROLLBACK을 수행하기 전까지 30번 부서 행 데이터를 조작하려는 다른 세션은 대기상태가 된다.

- 이렇게 특정 세션에서 데이터 조작이 완료될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상을 HANG이라고 한다.

- 명령프롬프트의 UPDATE문은 토드 세션의 트랜잭션이 종료되기 전까지 수행되지 못한다.

- 즉 토드세션에서 COMMIT ,ROLLBACK 명령어를 실행해야 해당 데이터의 LOCK이 풀리고 명령프롬프트의 UPDATE문이 수행된다.

- 토드

  ```SQL
  COMMIT;
  ```

- 토드 세션의 COMMIT이 수행되자 바로 명령프롬프트에 명령이 수행되었다는 문구를 확인할 수 있다.

- 이제는 명령프롬프트 세션이 DEPTNO가 30번인 행을 작업하기에 LOCK상태가되고 토드세션에서 해당 테이블을 조회해도 명령프롬프트에서 수행한 UPDATE가 반영되기 전의 결과를 보게 된다.

- 이제 명령프롬프트에서 COMMIT명령어를 내려 두 세션에서 같은 데이터를 볼 수 있도록 한다.

### LOCK 종류

- LOCK은 이렇듯 하나의 데이터를 여러 곳에서 동시에 조작하려 할 때 발생할 수 있는 혼란을 최소화하기 위한 중요한 요소이다.
- 위에서 진행한 예제는 SQL문으로 조작하는 대상 데이터가 테이블의 특정 행 데이터일 경우 해당행만 LOCK이 발생한다는 의미로 행 레벨 록 이라고 한다.
- 만약 WHERE절을 지정하지 않은 UPDATE, DELETE문일 경우에는 테이블의 모든 행 데이터에 영향을 주는 명령어이므로 이 경우에는 테이블에 저장되어 있는 전체 행이 LOCK상태가 된다.

```SQL
UPDATE DEPT_TCL SET LOC = 'SEOUL';

DELETE FROM DEPT_TCL;
```

- 즉 다른 세션에서는 해당 테이블에 이미 저장되어 있는 행에 UPDATE, DELETE명령을 수행하기 위해서는 대기해야한다.
- 하지만 테이블 전체 행이 LOCK상태여도 INSERT문은 수행이 가능하다.
- 하지만 테이블에 변경되는 행의 수와는 상관없이 데이터 조작 명령어를 사용하는 데이터가 변경 중인 테이블은 테이블 단위 잠금이라는 의미로 테이블 레벨 록이 걸리게 된다.
- 즉 데이터를 변경 중인 세션외 다른 세션에서 DDL를 통한 테이블 구로즐 변경할 수는 없다.
- 데이터 조작 관련 SQL문을 어떤 방식으로 작성하느냐에 따라 테이블의 일부 데이터만 LOCK이 될수도 있고 테이블 전체 데이터가 LOCK이 될 수 있다는 점을 기억해야 한다.
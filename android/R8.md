[TOC]

# R8

- 안드로이드 스튜디오 3.4, AGP 3.4.0이상을 이용한다면 R8 컴파일러를 이용하여  미사용 코드, 리소스를 제거, 코드 난독화를 통해 앱의 크기를 줄일 수 있다.
- 여러 과정을 통해서 빌드시간이 좀 더 오리걸릴 수 있고, 개발자가 프로젝트에 맞게 적절한 처리가 없다면 앱이 정상 작동하지 않을 수 있다.

## Code shrinking (코드 축소)

- 앱 모듈, 라이브러리에서 사용하지 않는 코드를 찾아 안전하게 제거한다.
- R8 컴파일러는 코드에 있는 모든 엔트리 포인트를 찾아 진입점을 찾는다.
- 이러한 엔트리 포인트는 안드로이드 플랫폼인 Activity, service를 사용하는 모든 클래스들을 의미한다.
- 엔트리포인트를 시작으로 R8 런타임에서 앱이 사용하는 모든 메소드, 멤버 변수를 찾아 그래프를 그린다.
- 그래프에 포함되지 않은 코드들은 삭제된다.
- 다음 그림에서 MainActivity 엔트리 포인트에서 접근하는 foo(), faz(), bar(), AwsomeApi.class가 그래프에 그려졌고 OkayApi.class와 해당 메서드가 그래프에 포함되지 않아 삭제된다.

<img src="https://developer.android.com/studio/images/build/r8/tree-shaking.png"/>

- R8은 프로젝트의 R8 configuration file의 `-keep`규칙을 이용하여 엔트리 포인트를 결정한다.
- AGP, AAPT2가 자동적으로 앱의 activity, view, service에 대한 keep 규칙을 자동적으로 생성해준다.
- 이러한 규칙을 커스텀하게 사용하면 이용하면 접근하지 않은 OkayApi.class를 엔트리 포인트르 취급할 수 있게 해준다.

### Customize code keep

- 대부분의 상황에서는 기본 설정(*proguard-android- optimize.txt*)만 있다면 사용하지 않는 코드를 제거하는데에는 문제가 없을 수 있다.
- 하지만, 특정 상황에서는 R8이 명확하게 분석하기 어려워 실제로 필요한 코드를 삭제할 수 있다.
- 다음같은 상황에서는 필요한 코드가 의도치 않게 코드가 삭제될 수 있다.
  - 앱이 JNI 메서드를 호출할 경우
  - 런타임에 리플렉션으로 코드를 찾을 경우
- 테스트를 하다보면 에러가 발생하지만 buildType이 release인 경우에 코드 축소를 하다보면 이런 상황을 빠르게 접하지 못 할 수 있다. (삭제된 코드들은 따로 [보고서 형태로도 받아 볼 수 있다](#삭제된-코드-보고서로-받아보기))
- proguardFile에 `-keep`을 추가하여 R8에서 삭제할 수 없도록 한다.

```
-keep public class MyClass
```

- 혹은 삭제하지 않고 유지하고 싶은 코드에 `@keep`을 추가할 수도 있다.
- 메서드나 필드에 추가함으로서 해당 클래스 또한 삭제되지 않는다.
- 다만 `@keep` 어노테이션은 AndroidX Annotations Liabary에 포함되어 있고 AGP로 패키징된 proguard rules 파일이 있을 경우에 동작한다.

> https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt
> https://android.googlesource.com/platform/sdk/+/master/files/proguard-android-optimize.txt

### 삭제된 코드 보고서로 받아보기

- 일반적으로 삭제된 코드들은 `build/outputs/mapping/{buildVarient}/usage.txt` 에 작성된다.
- 다음을 proguard rule에 넣으면 원하는 곳에 보고서를 생성해준다.
  - `-printusage <output-dir>/usage.txt`
- 실제로 사용되지 않는 몇몇 변수와 메서드를 작성하면 `usage.txt`에 나타나게 된다.

<img width="300" alt="스크린샷 2022-04-16 오후 5 25 47" src="https://user-images.githubusercontent.com/58923717/163668083-eda61077-2ca0-4872-a6d2-0121bec188d9.png" />

<div>
<img width="370" alt="스크린샷 2022-04-16 오후 5 27 37" src="https://user-images.githubusercontent.com/58923717/163668119-4bd80c61-26de-4e2a-b8d7-a0972c6f3f13.png" />
<img width="370" alt="스크린샷 2022-04-16 오후 5 29 46" src="https://user-images.githubusercontent.com/58923717/163668183-df951d14-77bb-41e1-98dd-c5bbb4c41e87.png" />
</div>


### Usage

#### build.gradle
```groovy
android {
    buildTypes {
        release {
            // 릴리즈 빌드 타입에 코드 축소, 난독화, 최적화를 진행하도록 한다.
            minifyEnabled true
        }
    }
}
```

#### Proguard-rules configuration options

##### keep

>  보존된다 -> 사용되지 않아도 삭제되지 않고, 난독화 되지 않는다.

- `-keep [,modifier, ...] class_specification`
  - 특정 클래스들이나 클래스 멤버들(필드, 메서드)을 엔트리 포인트로 지정한다.
  - 클래스와 클래스 멤버는 보존된다.
  - 라이브러리를 처리하기 위해서는 접근할 수 있는 모든 요소를 public하게 지정해야 한다.
- `-keepclassmembers [,modifier, ...] class_specification`
  - 클래스가 사용되지 않을 경우 삭제되고, 클래스가 사용되면 난독화된다.
  - 클래스 멤버는 보존된다.
- `-keepnames class_specification`
  - 클래스와 클래스 멤버에서 사용되지 않은 경우 제거되고 사용될 경우 난독화하지 않는다.
- `-keepclassmembernames class_specification`
  - 클래스는 사용되지 않으면 제거되고 사용될 경우 난독화 된다.
  - 클래스 멤버는 사용되지 않을 경우 삭제되고 사용될 경우 난독화 하지 않는다.
- `-printseeds [filename]`
  - 여러 `-keep`옵션으로 매칭되는 클래스와 클래스 멤버를 전부 기본 출력 파일에 프린트한다.
  - 출력된 리스트는 내부 클래스 멤버가 사용되었는지 구분하는데 유용한데, 특히 와일드카드를 사용할 때 유용하다.

##### shrinking

- `-dontshrink`
  - 제거하지 않을 입력을 지정한다.
  - 기본적으로 프로가드에서는 사용하지 않는 클래스와 클래스 멤버를 제가한다.
  - 여러 `-keep`옵션으로 지정된 것들만 유지하고, 직접적이든 간접적이든 `-keep` 옵션에 의존한다.
  - optimization 단계 이후에 shrinking 단계에서 적용된다.
  - 몇몇 최적화가 더 많은 클래스나 클래스 멤버를 삭제할 가능성이 있기 때문이다.
- `-printusage [filename]`
  - 입력 클래스 파일에서 제거된 코드 리스트를 보여준다.
  - 리스트는 기본 출력이나 `[filename]`에 작성된다.
  - 이걸 통해 사용되지 않는 코드를 리스트업할 수 있다.

##### optimization 

- `-dontoptimize`
  - 입력 파일의 최적화를 진행하지 않는다.
  - 기본적으로 프로가드는 모든 코드를 최적화한다.
  - 클래스와 클래스 멤버를 인라인하고 머지시키고 바이트 코드 레벨에서 모든 메서드를 최적화한다.

- `-optimizations [optimization_filter]`
  - 보다 세밀하게 최적화옵션을 지정한다.
- `-optimizationpasses n`
  - 최적화를 수행할 횟수를 지정한다.
  - 기본적으로 한 번만 수행된다.
  - 여러번 수행할 경우 보다 개선될 수 있다.
  - 만약 최적화가 된 후에도 개선된점이 없다면, 최적화가 끝났다는 것을 의미한다.
- `-assumenosideeffects class_specification`
  - 값을 반환하는 것 외에 어떠한 사이드 이펙트가 없는 메서드를 지정한다.
  - 예를 들어`System.currentTimeMillis()` 같은 메서드다.
  - 최적화 단계에서 프로가드가 반환 값이 사용되지 않다고 판단할 수 있는 경우해당 메서드를 호출하는 것들을 삭제할 수 있다.
  - 프로가드가 자동적으로 각 메서들르 찾아 코드를 분석할 것이다.
  - 그러나 라이브러리 코드는 분석하지 못 한다.
  - 이 옵션을 통해 로깅 코드를 제거할 수 있다.
  - 프로가드는 해당 메서드를 전체의 과정에 이 옵션을 적용시킨다.
  - 일반적으로 추측해서 사용하는 것은 위험하고 어떤 것을 하는 것인지 잘 알고 이 옵션을 사용해야 한다.

```
# 로깅 제거 옵션
-assumenosideeffects class android.util.Log {
    public static int v (...);
    public static int d (...);
    public static int i (...);
    public static int w (...);
    public static int e (...);
}
```

##### fiters

- 프로가드에서는 파일 이름, 경로, 클래스, 속성, 최적화 등과 관련된 여러 옵션을 제공해준다.
- 필터는 와일드카드(`?`, `*`, `**`)를 포함하고 쉼표로 구분된다.
- 리스트에 있는 아이템(파일 이름, 클래스 등)과 매칭되는 것만 필터를 통과한다.
- 와일드카드는 사용되는 필터의 이름의 종류에 따라 다르지만, 일반적으로 다음 것들이 일반적이다.
  - `?` : 이름에서 단일 문자와의 매칭
  - `*` : 패키지 구분자(`.`)나 파일 구분자(`/`)를 포함하지 않고 이름의 모든 부분과 매칭
  - `**` : 패키지, 파일 구분자의 구분 기호를 포함할 수 있고, 이름의 모든 부분과 매칭
- 예를들어 `foo,*bar`는 `foo`와 `bar`로 끝나는 어떤 문자도 매칭된다.
- 또한 `!`를 붙여서 일치하는 것을 더이상 시도하지 않도록 할 수 있다.
- 그래서 이름이 `!`필터와 일치하면 다음 이름을 허용하지 않게 된다.
- 예를 들어 `!foo,*bar`일 때 `bar`로 끝나는 이름과 매칭하지만 `foobar`은 제외된다.

##### Class specification

- 옵션에서 `class_specification`로 작성된 부분에서 다음 템플릿을 통해 사용할 수 있다.

```
[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname
    [extends|implements [@annotationtype] classname]
[{
    [@annotationtype]
    [[!]public|private|protected|static|volatile|transient ...]
    <fields> | (fieldtype fieldname [= values]);

    [@annotationtype]
    [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...]
    <methods> | <init>(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...) [return values]);
}]
```

- `[]` 내부에 있는 것들은 옵셔널이다.
- `...`로 되어 있는 줄임말은 앞의 항목에서 임의의 수가 지정될 수 있음을 의미한다.
- `|` 여러 대안을 의미한다.
- `()`괄호는 속해있는 그룹을 의미한다.
- 들여쓰기는 큰 의미없고 가독성을 위한 처리이다.
- `class`는 모든 인터페이스나 클래스를 의미한다.
- `interface`는 오직 인터페이스로만으로 제한한다.
- `enum`은 이넘 클래스로 제한한다.
- `interface` 혹은 `enum` 앞에 `!`를 지정하면 각 인터페이스나 이넘이 아닌 클래스로 제한된다.
- `classname`은 반드시 정규화된 이름이어야 한다.
  - `java.lang.String`과 같이 작성되어야 한다.

  - 내부 클래스인 경우 `$`로 구분한다. `java.lang.Thread$State`

  - `classname` 다음 규칙을 따른다.
  - `?` : 클래스 이름에서 단일 문자와 일치해야 한다.
    - `com.example.Test?`일 경우 `com.example.Test1`, `com.example.TestB`와 일치한다.
    - `com.example.Test12`는 일치하지 않는다.
  - `*` : 패키지 구분자를 제외하고 클래스 이름과 일치해야 한다.
    - `com.example.*Test*`일 경우 `com.example.Test`, `com.example.YourTestApplication`와 일치한다.
    - `com.example.subpackage.MyTest`는 일치하지 않는다.
    - 일반적으로 `com.example.*` 이렇게 사용하고 해당 패키지의 모든 클래스와 매칭되고 `com.example`의 서브 패키지의 클래스들은 모두 무시한다.
  - `**` : 패키지 구분자를 포함하여 클래스 이름과 일치해야 한다.
    - `**.Test`일 경우 Test라는 이름을 갖는 모든 클래스와 매칭된다.

    - `com.example.**`일 경우 `com.example`에 존재하는 클래와 하위 패키지의 모든 클래스와 매칭된다.

  - 편의성과 이전 버전과의 호환성을 위해 클래스 이름이 `*`인 경우 는 패키지에 관계없이 단독으로 사용될때 모든 클래스를 의미한다. (`-keep class *`)
 - 필드와 메서드는 메서드 매개변수 리스트에 매개변수 이름으로 없는 것을 제외하면 Java처럼 구분할 수 있다.
    - 다음과 같은 와일드 카드가 있다.
        - `<init>` : 생성자와 매칭
        - `<fields>` : 필드와 매칭
        - `<methods>` : 메서드와 매칭
        - `*` : 모든 필드 혹은 메서드와 매칭

    - 와일드 카드에는 리턴 타입을 지정하지 않고, `<init>`만 매개변수 리스트가 있다.
    - 필드와 메서드에서 적용되는 규칙은 다음과 같다.
        - `?` : 메서드 이름과 일치하는 단일 문자와 일치해야 한다.
        - `*` : 메서드 이름의 일부분과 일치해야 한다.

 - 타입지정에는 다음 와일드 카드가 있다.
    - `%` : primitive 타입과 일치해야 한다.
    - `?` : 클래스 이름에서 단일 문자와 일치해야 한다.
    - `*` : 패키지 구분자를 제외하고 클래스 이름과 일치해야 한다.
    - `**` : 패키지 구분자를 포함해서 클래스 이름과 일치해야 한다.
    - `***` : primitive타입, non-primitive, array, non-array 타입과 일치해야 한다.
    - `...` : 어떤 타입의 매개변수 갯수로 일치해야 한다.
    - `?, *, **` primitive타입과 매칭되지 않는다.
    - `** get*()`는 `java.lang.Object getObject()`과 일치하지만 `float getFloat()`, `java.lang.Object[] getObjects()`는 일치하지 않는다.
    - `public static`은 혼합해서 사용될 수 있지만 `public`, `protected`하나만을 사용해야 한다.





## Resource shrinking (리소스 축소)

## Obfuscation (난독화)

## Optimization (최적화)







## Reference

https://www.guardsquare.com/

https://developer.android.com/studio/build/shrink-code

[Distinguishing between the different ProGuard “-keep” directives – jebware.com](https://jebware.com/blog/?p=418)


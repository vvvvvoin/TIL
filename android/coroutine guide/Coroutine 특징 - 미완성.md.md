# Coroutine 특징 - 미완성

코틀린은 여러 표준 라이브러리에서 최소 수준의 API를 제공하여 다양한 라이브러들이 코루틴을 활용할 수 있도록 한다. 다른 많은  비슷한 기능을 같는 언어들과 달리, `async`, `await`같은 키워드가 코틀린에는 없고, 표준 라이브러리의 일부도 아니다. 더욱이 코틀린에서는 *suspending function*이라는 특징으로 미래의 약송보다 안정성과 오류 발생이 더 적은 추상를 제공한다.

kotlinx.coroutines는 jetBrains에서 개발중인 라이브러리이다. 이는 고수준의 coroutine에서 사용가능한 launch, aync 등을 포함한 기초적인 요소들를 제공해준다.





runBlocking{} 블록은 주어진 블록이 완료될 때까지 현재 스레드를 멈추는 새로운 코루틴을 생성하여 실행하는 코루틴 빌더 

반면 coroutineScope 블록은 자식블록을 수행하는 동안 다른 바깥쪽 스레드를 블록하지 않는다는 차이점이 있다. 반면에 runBlocking scope는 해당 스코프를 실행시킨 스레드가 멈추는 차이가 있다.



**스코프의 존재이유**

모든 코루틴들은 각자의 스코프를 갖습니다. runBlocking{ } 코루틴 빌더등을 이용해 생성 된 코루틴 블록 안에서 launch{ } 코루틴 빌더를 이용하여 새로운 코루틴을 생성하면 현재 위치한 부모 코루틴에 join() 을 명시적으로 호출할 필요 없이 자식 코루틴들을 실행하고 종료될 때까지 대기 할 수 있습니다.

coroutine block은 내부(자식) 코루틴이 모두 완료될때까지 대기한다. (join없이 순서를 보장할 수 있음)



**경량화인 이유?????**

Scope에서 작성된 코드들은 Continuation라는 단위로 바뀌게 된다. 생성 초기에는 suspend상태로 존재하다 resume()요청으로 해당 코드들이 실행된다. reumse시에는 현재 컨텍스트에 dispatch(스레드 전환) 가 필요한지 isDispatchNeeded() 함수를 이용해 확인 한 후 dispatch가 필요하면 dispatch()함수를 호출하여 적합한 스레드로 전달하여 수행됩니다.





